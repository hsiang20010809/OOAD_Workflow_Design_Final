1. 設計架構
請解釋您在此專案中應用的設計模式，特別是組合模式(Composite Pattern)如何幫助您處理單一形狀和群組形狀的統一操作？
ANS:在本專案中，組合模式(Composite Pattern)是核心設計模式之一。
    我實現了一個統一的Shape抽象基類，使單一圖形(Rect、Oval)和複合圖形(Composite)都實作相同的介面。
    這種設計讓我能夠：
        1.透過統一介面處理所有形狀，不需區分是單一或群組形狀
        2.以遞迴方式處理複合形狀，例如Composite.draw()會自動呼叫其所有子形狀的draw()方法
        3.實現形狀的巢狀群組，理論上可無限層級
        4.簡化主程式碼，因為Canvas只需維護一個Shape清單，而不需知道各元素的具體類型
        5.組合模式特別適合這類需要樹狀結構表示的圖形編輯器，使得操作更加一致且程式碼更加簡潔。

2. 繼承與多型
Shape類別定義為抽象類別而非介面的原因是什麼？這個設計決策帶來哪些優勢和限制？
ANS:我選擇將Shape設計為抽象類別而非介面，主要基於以下考量(繼承與多型)：
    可提供共用實作：許多形狀有共同邏輯，如標籤處理、選取狀態管理、顏色設定等，抽象類別允許我實作這些共用功能
    維護狀態：抽象類別可以包含成員變數，如位置(x,y)、寬高、顏色等所有形狀都需要的屬性
    默認實作：部分方法可提供預設實現，子類只需覆寫特定行為
    限制方面，Java不支援多重繼承，所以選擇抽象類別意味著子類不能再繼承其他類別。但在此專案中，這不構成問題，因為所有形狀的核心行為都已在Shape類中定義。

3. 事件處理機制
Canvas類別如何處理不同模式下(繪製矩形、橢圓、選取、連線)的滑鼠事件？請說明模式切換如何影響程式行為。
ANS:Canvas利用狀態模式處理不同模式下的滑鼠事件。我設計了一個Mode列舉，包括RECT、OVAL、SELECT和不同的連線模式。

    在mousePressed事件處理中：

    RECT/OVAL模式：創建新形狀並添加到畫布
    SELECT模式：檢查點擊的位置是否在形狀上，設定選擇狀態或啟動框選
    連線模式：尋找起始連接點

    在mouseDragged事件處理中：

    RECT/Oval模式:完成形狀創建或移動
    SELECT模式：移動選中的形狀或擴展選擇區域
    連線模式：判斷連線操作

    在mouseReleased事件處理中：

    完成形狀創建或移動
    確認選擇區域內的形狀
    完成連線建立

    模式切換由工具欄按鈕觸發，改變Canvas的currentMode屬性，進而影響滑鼠事件的處理邏輯。

4. 連接線實現
Link類別如何確定兩個形狀間的連接點？當形狀移動時，連接線如何保持正確的連接狀態？
ANS:Link類別處理形狀間的連接，關鍵實現如下：

    每個形狀透過getConnectionPorts()方法提供可用的連接點（通常在四邊中點）
    連線建立時，系統會計算兩個形狀間最近的連接點對，作為連線的起點和終點
    形狀移動時，連接線會透過起終點形狀的引用，重新查詢連接點位置
    使用觀察者模式，當形狀位置改變時通知相關連接線更新
    為優化視覺效果，連接點選擇算法會考慮形狀的相對位置，優先選擇形狀之間最直接的連接路徑。
    不同連接線類型（關聯、泛化、組合）共享相同的連接機制，但在繪製時使用不同的線型和箭頭樣式。

5. 深度管理
您的程式中使用了depth屬性來管理形狀的疊加順序，請解釋此機制如何運作，以及為什麼將Rect的深度設為10而Oval設為5？

6. 選擇與框選邏輯
請詳細說明Canvas中的框選功能是如何實現的，包括如何判斷一個形狀是否在選擇範圍內。
ANS:框選功能實現如下：

    在SELECT模式下，使用者按下滑鼠且未命中任何形狀時，啟動框選
    拖曳時，記錄起始位置和當前位置，繪製虛線選擇框
    釋放滑鼠時，遍歷所有形狀，檢查哪些在選擇框內

7. 群組與解群組
當執行群組操作時，原始形狀與Composite之間的關係如何處理？解群組時又如何確保原始形狀的屬性不會丟失？
ANS:群組操作的處理流程：

    創建新的Composite對象
    將選中形狀從Canvas的主形狀列表中移除
    將這些形狀添加為Composite的子形狀
    計算Composite的邊界以包含所有子形狀
    將Composite添加到Canvas的形狀列表

    解群組操作則相反：

    獲取選中的Composite對象
    從Canvas的形狀列表中移除該Composite
    將所有子形狀添加回Canvas的主形狀列表
    保持子形狀的位置和屬性不變
    關鍵在於Composite會保存子形狀的相對位置，當Composite移動時，所有子形狀會保持相對位置關係一起移動。
    標籤和樣式方面，Composite可以擁有自己的標籤，但也會在繪製時呈現所有子形狀的標籤和樣式。

8. 標籤自訂機制
CustomLabelDialog與Shape類別之間的互動如何設計？標籤的樣式變更如何應用到不同形狀類別？
ANS:標籤自訂透過CustomLabelDialog實現：

    當用戶選中形狀並觸發標籤編輯時，系統創建一個CustomLabelDialog實例
    對話框預載當前形狀的標籤設置（文字、字體、顏色等）
    用戶修改並確認後，對話框將新設置應用到選中形狀的labelProperty對象
    Shape基類定義了標籤繪製的通用邏輯，但具體子類可以覆寫位置計算

9. 擴展性考量
如果要在系統中添加一個新形狀類型(例如三角形)，需要修改哪些部分？您的設計如何減少因擴展帶來的程式碼變更？
ANS:添加新形狀（如三角形）需要：

    1.創建新的形狀類，繼承Shape
    public class Triangle extends Shape {
    // 實現必要方法
    }
    2.實現必要的抽象方法：
        draw(Graphics g)：三角形的繪製邏輯
        contains(Point p)：判斷點是否在三角形內
        getConnectionPorts()：定義三角形的連接點
        getBounds()：計算三角形的邊界矩形
    3.在UI中添加創建三角形的按鈕，並在WorkflowEditor中處理相應事件
    4.在Canvas的事件處理中添加TRIANGLE模式支持
    現有設計已經將大部分共用邏輯抽象到Shape類，所以新增形狀只需專注於其獨特特性。主要修改點在UI和事件處理上，核心結構無需變更，體現了良好的擴展性。


10. 錯誤處理
您的程式如何處理可能的異常情況，例如使用者嘗試連接不存在的形狀或執行無效的群組操作？